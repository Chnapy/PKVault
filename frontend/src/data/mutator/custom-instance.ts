import z from 'zod';

const baseURL = new URL(window.location.href).searchParams.get('server') || window.location.origin;

console.log('Server url =>', baseURL);

export const getApiFullUrl = (url: string) => `${baseURL}${url}`;

export type ResponseBack<D = unknown> = z.infer<typeof responseBackSchema> & { data: D }
export const responseBackSchema = z.object({
    // data: z.unknown(),
    headers: z.instanceof(Headers),
    status: z.number().int(),
});

export const customInstance = async <T extends ResponseBack>(url: string, init?: RequestInit): Promise<T> => {
    const targetUrl = normalizeUrlParams(getApiFullUrl(url));

    const res = await fetch(targetUrl, init);

    if (!res.ok) {
        throw new QueryError(res);
    }

    const body = [ 204, 205, 304 ].includes(res.status) ? null : await res.text();
    const data = body ? JSON.parse(body) : {};

    return { data, status: res.status, headers: res.headers } satisfies ResponseBack as T;
};

/**
 * Normalize url params removing 'null' values generated by Orval.
 */
const normalizeUrlParams = (url: string): string => {
    const urlObj = new URL(url);

    const searchParams = new URLSearchParams();

    urlObj.searchParams.forEach((value, key) => {
        if (value !== 'null') {
            searchParams.append(key, value);
        }
    });

    urlObj.search = '?' + searchParams;

    return urlObj.href;
};

export default customInstance;

export class QueryError extends Error {
    public readonly url: string;
    public readonly status: number;
    public readonly statusText: string;
    public readonly errorMessage: string | null;
    public readonly errorStack: string | null;

    constructor(res: Response) {
        const errorMessage = QueryError.getHeaderContent(res.headers.get('error-message'));
        const errorStack = QueryError.getHeaderContent(res.headers.get('error-stack'));

        super("Query error:"
            + `\nurl = ${res.url}`
            + `\nstatus = ${res.status} / ${res.statusText}`
            + `\nerror message = ${errorMessage}`
            + `\nerror stack =\n${errorStack}`);

        this.url = res.url;
        this.status = res.status;
        this.statusText = res.statusText;
        this.errorMessage = errorMessage;
        this.errorStack = errorStack;

        Object.setPrototypeOf(this, QueryError.prototype);
    }

    private static getHeaderContent(value: string | null): string | null {
        try {
            return JSON.parse(value!);
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
        } catch (_) {
            return value;
        }
    }
}

// override the return error type
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export type ErrorType<_> = QueryError;

// // In case you want to wrap the body type (optional)
// // (if the custom instance is processing data before sending it, like changing the case for example)
// export type BodyType<BodyData> = CamelCase<BodyType>;
